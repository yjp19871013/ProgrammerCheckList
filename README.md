# **软件工程师设计和开发方案自查文档**
本文档是个人工作过程中遇到的问题以及解决方案的总结，可能个人能力有限，如果有不合理的地方或者思虑不周之处，欢迎大家指正。个人工作重心在后端，所以总结的问题和方案基本都是后端的。后续有新的经验我会不断更新文档，给大家和自己提供更加直观的方案。

## **1 概述**
作为一名工程师，工作多年最重要的就是经验和直觉，而所谓的经验和直觉，更多是对自己遇到问题的一系列解决方案的总结。工程师的历练过程很简单，无非是跳坑，爬坑，总结经验的过程，基于该文档，总结一下自己踩过的坑和采用的方案，作为自己的笔记，也提供给大家一些方案，方便大家解决工作中的问题。

## **2 架构设计篇**
大家可能会觉得架构设计是架构师的事情，和程序员关系不大，但是，好的程序员应当具备一定的架构思维，这样更有利于写出更加整洁且具有前瞻性的代码，降低项目开发中的风险，避免返工，让系统具备更好的容错能力和对需求变更的适应能力。

### **2.1 是否采用领域驱动设计？**
领域驱动设计可以很好的划分领域边界，对于抵御需求变更具有很好的效果，讲不可控的程序员编码行为限制在影响力有限的领域内，对于限制程序员天马行空的代码也很有用。

### **2.2 MVC和领域驱动设计矛盾吗？**
MVC是一种架构模式，目前使用十分广泛，领域驱动设计则是一种架构风格，两者并不冲突，不用争论使用MVC还是使用领域驱动设计，目前我常采用的方式就是MVC大框架下采用领域驱动设计，结合必要的其他架构模式。

### **2.3 采用何种领域驱动设计模型？充血模式还是失血模式？**
软件的特性就是变，架构也不会一成不变，领域驱动设计是一种架构风格，所以考虑这个问题我们可以考虑哪种方式对架构变化的适应性更好，那很显然是充血模式。

有些人会站在开发的角度说失血模式更简单，便于开发，项目规模不大，使用失血模式就足够。但是，现实是残酷的，原本以为规模不大的项目终归会变大，另外保持思考问题的纯粹性，既然是架构问题，要从架构的角度考虑，不要引入不必要的外部干扰。即使项目大到需要拆分微服务的时候，充血模式也能很好地减少你的工作量，开发阶段的投入换来的是后期的可进可退，何乐而不为呢。

### **2.4 领域驱动设计的领域边界有太多冗余的实体设计，如何避免？**
关于这个问题，个人建议是不要避免，做个老实的搬砖人，需要冗余就冗余。清晰的领域边界带来的是清晰的代码，带来的是对领域外变更极强的适应能力。清晰的领域边界也有利于进行服务拆分，识别服务边界，当需要拆分服务时，我们只需要把对应的包拷贝到新的服务，就完成了拆分。

### **2.5 是否使用微服务架构？何时使用？**
是否使用微服务架构没有定论，甚至于个人不太建议完全按照微服务的设计理念去划分微服务，这就牵扯到一个问题，微服务到底微到什么程度？目前个人微服务的划分主要有三个依据：按功能，按机制，按领域。

按功能就是考量一个功能是否会被多个服务所共享，比如鉴权和授权服务，对于大部分服务都不可避免的需要鉴权和授权，那么就把鉴权和授权提取为一个服务，统一管理服务的权限问题。

按机制就是看一种机制是否是很多服务都会用到的，比如websocket，这时候就可以考虑单独创建服务解决这个机制问题。

按领域就是当发现一个服务的领域越来越多时，就可以考虑将其中比较大的或者功能复杂的领域拆分到一个新的服务当中，这样可以减少原有服务的领域量，同时，这些被拆分出去的领域很可能是一些比较重要的领域，也可能是一些变异比较多的领域，拆分出去有利于减少它们对目前现有系统的影响，也有利于它们之后的变更。

基于三个依据拆分之后，拆分出去的服务依然会进一步变大，这时候再次遵循三个依据进行拆分，形成微服务拆分的迭代流程。

### **2.6 服务间通信采用服务调用还是事件驱动？**
关于这个问题，不要顾此失彼，不要一概而论，服务调用适合于应答-响应模式，对于处理时间较短的请求，采用服务调用当然是最合适不过的方式，所以，大部分服务间通信都是采用这种模式的。服务调用有HTTP和GRPC两种方式，各有利弊，但是建议对接前端服务的一定要采用HTTP接口，服务内部的两种方式均可，但是需要高并发量和流模式的情况，毋庸置疑采用GRPC。

事件驱动更适合于处理时间较长或者并发要求较高的请求，这样我们可以先尽快响应用户，之后通过异步消息处理任务。这就带来使用事件驱动需要关注很多的问题：数据的一致性问题，事件的观测性问题，事件的回溯问题等等，这在后续的问题中会有所解答。

## **3 开发篇**
这里虽然是开发篇，主要包括开发阶段才能识别出来的问题，也包括一些设计问题，这就是前文提到的，开发人员需要具备一定的架构设计能力和思想的原因，很多的架构的细节问题只有在编码过程中才会被识别出来，这时候，架构师可能不在你的身边，希望不加班完美的解决问题，只能靠自己了。

### **3.1 数据库实体设计**
这里给出数据库实体设计时需要考虑的一些问题以及解决方案，可以通过自己的实体对照问题列表进行走查。

**(1) 是否是有状态的(不单纯只是查)?**

有状态的实体类需要添加主键ID，如果是无状态的(只会查询信息)，不需要主键ID，将其设计为值对象。

**(2) 是否要软删除？**

对于涉及审计，法务或者用户权益等重要数据，需要人工恢复或者人工删除，这类数据需要软删除；其他的数据可以不采用软删除。

**(3) 是否需要保证创建数据只有一条？**

比如创建的资源具有限制：一个租户不允许存在同名资源，不同租户间允许同名，为了满足这样的要求我们不能把名称字段指定为unique，这样会导致不同租户间也不能同名(按照租户分库分表除外，可以指定为unique)。这个时候可以基于几个联合字段生成一个unique的check code字段，这个字段是unique的，基于该字段实现upsert操作，而在删除时，如果采用了软删除，基于删除的当前时间生成新的checkcode，更新后再删除，这样可以防止后续该租户再创建相同名称的资源时check code相同无法创建的问题。

**(4) 是否需要避免同一行数据的更新冲突？**

如果需要避免对同一行数据更新出现冲突，可以使用乐观锁。

**(5) 如果采用了事件驱动，消息中如果有上下文数据，如何保存？**

如果消息接收和响应在同一个运行上下文中，那么返回事件响应时直接返回消息上下文即可；如果消息接收和响应不在一个运行上下文中，那么需要将上下文持久化，如果资源和上下文一对一，那么简便起见，可以作为对应的资源表中的一列保存，如果存在一对多关系，那么最好将上下文分到另一个表中保存。

**(6) 字段的类型和长度是否专门进行了思考？**

要对数据库实体类的每一个字段进行思考，明确思考其类型和长度。

**(7) 字段命名是否合理？**

字段命名要明确表示该字段的含义。

**(8) 是否与其他实体存在关联？**

要合理处理实体间的关联关系

### **3.2 错误处理是否可以忽略？**
除了确实经过考量后可以忽略的错误可以谨慎的忽略，一般情况下，错误不能简单忽略，即便忽略，也应该在日志中打印错误，尽量做到不要不做任何处理放过一个错误

### **3.3 为了安全起见，能否将所有的数据库操作都放在事务中？**
事务的性能还是会低很多的，一般编码的原则是，能不采用事务的前提下尽量不要使用，另外如果多个数据库操作中只有一个写操作(插入或修改)，可以考虑能否通过调整操作顺序，将写操作放在最后一步，这样就可以避免使用事务了。

### **3.4 是否对所有警告进行了思考？**
不要忽略代码中的任何警告，可能警告就是某个隐蔽Bug的答案。一定要对代码中的所有警告进行考察(甚至于拼写)，只留下你很确信不会有问题的警告

### **3.5 是否有编写的很“蹩脚”的逻辑代码**
代码逻辑和需求以及架构有着非常隐蔽的关系，如果有一段逻辑代码让你写的非常“蹩脚”，可以跳出代码看看需求或者架构，可能这“蹩脚”的代码反映了架构或者需求上的问题，单从代码角度硬写，逻辑会非常不清晰，可能反而导致后续相关模块的代码也会出现问题。如果出现无论怎么写都“蹩脚”的代码，那就跳出程序员的身份，去考察一下需求和架构，或许你会有新的解决方式和想法。

### **3.6 命名是否规范？**
规范的命名可以有效提升代码的可读性和维护性，代码是写给人读的，更进一步，代码是写给别人读的，自己能读懂的代码不代表别人能读懂的。这中间还包括尽量使用一些耳熟能详的设计模式，通过命名说明采用的设计模式，作为内行人之间沟通的一种方式。

### **3.7 封装是否做到了合理？**
需要封装的场景往往都由非常明显的一个特征：重复。封装就是避免重复并提高复用性的一种手段。对一些字段的重复赋值，可以封装为函数；对一些字段的重复判断，可以封装为函数；对一个类中重复的代码段，可以封装为类方法；对不同类中的代码段，可以通过其作用和职责，考虑封装到一个新的类中；对于被其他数据库实体类引用的另一个实体类中的多个字段(非主键)，可以考虑把这几个字段提取到新的实体类，通过关联引用，等等。
